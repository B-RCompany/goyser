// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v4.25.3
// source: fumarole.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Fumarole_ListAvailableCommitmentLevels_FullMethodName = "/fumarole.Fumarole/ListAvailableCommitmentLevels"
	Fumarole_GetConsumerGroupInfo_FullMethodName          = "/fumarole.Fumarole/GetConsumerGroupInfo"
	Fumarole_ListConsumerGroups_FullMethodName            = "/fumarole.Fumarole/ListConsumerGroups"
	Fumarole_DeleteConsumerGroup_FullMethodName           = "/fumarole.Fumarole/DeleteConsumerGroup"
	Fumarole_CreateStaticConsumerGroup_FullMethodName     = "/fumarole.Fumarole/CreateStaticConsumerGroup"
	Fumarole_Subscribe_FullMethodName                     = "/fumarole.Fumarole/Subscribe"
	Fumarole_GetSlotLagInfo_FullMethodName                = "/fumarole.Fumarole/GetSlotLagInfo"
	Fumarole_GetOldestSlot_FullMethodName                 = "/fumarole.Fumarole/GetOldestSlot"
)

// FumaroleClient is the client API for Fumarole service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FumaroleClient interface {
	ListAvailableCommitmentLevels(ctx context.Context, in *ListAvailableCommitmentLevelsRequest, opts ...grpc.CallOption) (*ListAvailableCommitmentLevelsResponse, error)
	GetConsumerGroupInfo(ctx context.Context, in *GetConsumerGroupInfoRequest, opts ...grpc.CallOption) (*ConsumerGroupInfo, error)
	ListConsumerGroups(ctx context.Context, in *ListConsumerGroupsRequest, opts ...grpc.CallOption) (*ListConsumerGroupsResponse, error)
	DeleteConsumerGroup(ctx context.Context, in *DeleteConsumerGroupRequest, opts ...grpc.CallOption) (*DeleteConsumerGroupResponse, error)
	CreateStaticConsumerGroup(ctx context.Context, in *CreateStaticConsumerGroupRequest, opts ...grpc.CallOption) (*CreateStaticConsumerGroupResponse, error)
	Subscribe(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SubscribeRequest, SubscribeUpdate], error)
	GetSlotLagInfo(ctx context.Context, in *GetSlotLagInfoRequest, opts ...grpc.CallOption) (*GetSlotLagInfoResponse, error)
	GetOldestSlot(ctx context.Context, in *GetOldestSlotRequest, opts ...grpc.CallOption) (*GetOldestSlotResponse, error)
}

type fumaroleClient struct {
	cc grpc.ClientConnInterface
}

func NewFumaroleClient(cc grpc.ClientConnInterface) FumaroleClient {
	return &fumaroleClient{cc}
}

func (c *fumaroleClient) ListAvailableCommitmentLevels(ctx context.Context, in *ListAvailableCommitmentLevelsRequest, opts ...grpc.CallOption) (*ListAvailableCommitmentLevelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAvailableCommitmentLevelsResponse)
	err := c.cc.Invoke(ctx, Fumarole_ListAvailableCommitmentLevels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fumaroleClient) GetConsumerGroupInfo(ctx context.Context, in *GetConsumerGroupInfoRequest, opts ...grpc.CallOption) (*ConsumerGroupInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConsumerGroupInfo)
	err := c.cc.Invoke(ctx, Fumarole_GetConsumerGroupInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fumaroleClient) ListConsumerGroups(ctx context.Context, in *ListConsumerGroupsRequest, opts ...grpc.CallOption) (*ListConsumerGroupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConsumerGroupsResponse)
	err := c.cc.Invoke(ctx, Fumarole_ListConsumerGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fumaroleClient) DeleteConsumerGroup(ctx context.Context, in *DeleteConsumerGroupRequest, opts ...grpc.CallOption) (*DeleteConsumerGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteConsumerGroupResponse)
	err := c.cc.Invoke(ctx, Fumarole_DeleteConsumerGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fumaroleClient) CreateStaticConsumerGroup(ctx context.Context, in *CreateStaticConsumerGroupRequest, opts ...grpc.CallOption) (*CreateStaticConsumerGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateStaticConsumerGroupResponse)
	err := c.cc.Invoke(ctx, Fumarole_CreateStaticConsumerGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fumaroleClient) Subscribe(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SubscribeRequest, SubscribeUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Fumarole_ServiceDesc.Streams[0], Fumarole_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, SubscribeUpdate]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Fumarole_SubscribeClient = grpc.BidiStreamingClient[SubscribeRequest, SubscribeUpdate]

func (c *fumaroleClient) GetSlotLagInfo(ctx context.Context, in *GetSlotLagInfoRequest, opts ...grpc.CallOption) (*GetSlotLagInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSlotLagInfoResponse)
	err := c.cc.Invoke(ctx, Fumarole_GetSlotLagInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fumaroleClient) GetOldestSlot(ctx context.Context, in *GetOldestSlotRequest, opts ...grpc.CallOption) (*GetOldestSlotResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetOldestSlotResponse)
	err := c.cc.Invoke(ctx, Fumarole_GetOldestSlot_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FumaroleServer is the server API for Fumarole service.
// All implementations must embed UnimplementedFumaroleServer
// for forward compatibility.
type FumaroleServer interface {
	ListAvailableCommitmentLevels(context.Context, *ListAvailableCommitmentLevelsRequest) (*ListAvailableCommitmentLevelsResponse, error)
	GetConsumerGroupInfo(context.Context, *GetConsumerGroupInfoRequest) (*ConsumerGroupInfo, error)
	ListConsumerGroups(context.Context, *ListConsumerGroupsRequest) (*ListConsumerGroupsResponse, error)
	DeleteConsumerGroup(context.Context, *DeleteConsumerGroupRequest) (*DeleteConsumerGroupResponse, error)
	CreateStaticConsumerGroup(context.Context, *CreateStaticConsumerGroupRequest) (*CreateStaticConsumerGroupResponse, error)
	Subscribe(grpc.BidiStreamingServer[SubscribeRequest, SubscribeUpdate]) error
	GetSlotLagInfo(context.Context, *GetSlotLagInfoRequest) (*GetSlotLagInfoResponse, error)
	GetOldestSlot(context.Context, *GetOldestSlotRequest) (*GetOldestSlotResponse, error)
	mustEmbedUnimplementedFumaroleServer()
}

// UnimplementedFumaroleServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFumaroleServer struct{}

func (UnimplementedFumaroleServer) ListAvailableCommitmentLevels(context.Context, *ListAvailableCommitmentLevelsRequest) (*ListAvailableCommitmentLevelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAvailableCommitmentLevels not implemented")
}
func (UnimplementedFumaroleServer) GetConsumerGroupInfo(context.Context, *GetConsumerGroupInfoRequest) (*ConsumerGroupInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsumerGroupInfo not implemented")
}
func (UnimplementedFumaroleServer) ListConsumerGroups(context.Context, *ListConsumerGroupsRequest) (*ListConsumerGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConsumerGroups not implemented")
}
func (UnimplementedFumaroleServer) DeleteConsumerGroup(context.Context, *DeleteConsumerGroupRequest) (*DeleteConsumerGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteConsumerGroup not implemented")
}
func (UnimplementedFumaroleServer) CreateStaticConsumerGroup(context.Context, *CreateStaticConsumerGroupRequest) (*CreateStaticConsumerGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateStaticConsumerGroup not implemented")
}
func (UnimplementedFumaroleServer) Subscribe(grpc.BidiStreamingServer[SubscribeRequest, SubscribeUpdate]) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedFumaroleServer) GetSlotLagInfo(context.Context, *GetSlotLagInfoRequest) (*GetSlotLagInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSlotLagInfo not implemented")
}
func (UnimplementedFumaroleServer) GetOldestSlot(context.Context, *GetOldestSlotRequest) (*GetOldestSlotResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOldestSlot not implemented")
}
func (UnimplementedFumaroleServer) mustEmbedUnimplementedFumaroleServer() {}
func (UnimplementedFumaroleServer) testEmbeddedByValue()                  {}

// UnsafeFumaroleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FumaroleServer will
// result in compilation errors.
type UnsafeFumaroleServer interface {
	mustEmbedUnimplementedFumaroleServer()
}

func RegisterFumaroleServer(s grpc.ServiceRegistrar, srv FumaroleServer) {
	// If the following call pancis, it indicates UnimplementedFumaroleServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Fumarole_ServiceDesc, srv)
}

func _Fumarole_ListAvailableCommitmentLevels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAvailableCommitmentLevelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FumaroleServer).ListAvailableCommitmentLevels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Fumarole_ListAvailableCommitmentLevels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FumaroleServer).ListAvailableCommitmentLevels(ctx, req.(*ListAvailableCommitmentLevelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fumarole_GetConsumerGroupInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsumerGroupInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FumaroleServer).GetConsumerGroupInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Fumarole_GetConsumerGroupInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FumaroleServer).GetConsumerGroupInfo(ctx, req.(*GetConsumerGroupInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fumarole_ListConsumerGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConsumerGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FumaroleServer).ListConsumerGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Fumarole_ListConsumerGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FumaroleServer).ListConsumerGroups(ctx, req.(*ListConsumerGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fumarole_DeleteConsumerGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteConsumerGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FumaroleServer).DeleteConsumerGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Fumarole_DeleteConsumerGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FumaroleServer).DeleteConsumerGroup(ctx, req.(*DeleteConsumerGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fumarole_CreateStaticConsumerGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateStaticConsumerGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FumaroleServer).CreateStaticConsumerGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Fumarole_CreateStaticConsumerGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FumaroleServer).CreateStaticConsumerGroup(ctx, req.(*CreateStaticConsumerGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fumarole_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FumaroleServer).Subscribe(&grpc.GenericServerStream[SubscribeRequest, SubscribeUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Fumarole_SubscribeServer = grpc.BidiStreamingServer[SubscribeRequest, SubscribeUpdate]

func _Fumarole_GetSlotLagInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSlotLagInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FumaroleServer).GetSlotLagInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Fumarole_GetSlotLagInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FumaroleServer).GetSlotLagInfo(ctx, req.(*GetSlotLagInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Fumarole_GetOldestSlot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOldestSlotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FumaroleServer).GetOldestSlot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Fumarole_GetOldestSlot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FumaroleServer).GetOldestSlot(ctx, req.(*GetOldestSlotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Fumarole_ServiceDesc is the grpc.ServiceDesc for Fumarole service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Fumarole_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "fumarole.Fumarole",
	HandlerType: (*FumaroleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListAvailableCommitmentLevels",
			Handler:    _Fumarole_ListAvailableCommitmentLevels_Handler,
		},
		{
			MethodName: "GetConsumerGroupInfo",
			Handler:    _Fumarole_GetConsumerGroupInfo_Handler,
		},
		{
			MethodName: "ListConsumerGroups",
			Handler:    _Fumarole_ListConsumerGroups_Handler,
		},
		{
			MethodName: "DeleteConsumerGroup",
			Handler:    _Fumarole_DeleteConsumerGroup_Handler,
		},
		{
			MethodName: "CreateStaticConsumerGroup",
			Handler:    _Fumarole_CreateStaticConsumerGroup_Handler,
		},
		{
			MethodName: "GetSlotLagInfo",
			Handler:    _Fumarole_GetSlotLagInfo_Handler,
		},
		{
			MethodName: "GetOldestSlot",
			Handler:    _Fumarole_GetOldestSlot_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _Fumarole_Subscribe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "fumarole.proto",
}
